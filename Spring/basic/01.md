## Spring_Basic


클라이언트가 인트페이슨 DiscountPolicy뿐만 아니라, 구체 클래스인 FixDiscountPolicy도 함께 의존 하게 되면서 DIP를 위반 하게 됨.
-> 클라이언트 코드인 주문 서비스 구현체도 함께 변경해야하는 문제점.


순수 자바기준
애플리케이션의 전체 동작방식을 구성하기 위해 AppConfig를 생성하여 구현 객체를 생성하고, 연결하는 책임을 줬음.
이로써 클라이언트 객체는 자신의 역할만 실행하는 것에 집중하게 되고 책임이 명확하게 정의됨.


AppConfig를 구성 정보에서 역할과 구현을 명확히 분리시키고 역할이 잘 들어나게끔 변경.

AppConfig의 등장으로 애플리케이션이 크게 사용영역과 객체를 생성하고 구성하는 영역으로 분리됨.
정책을 변경하더라도 AppConfig가 있는 구성영역만 변경하면 사용영역과 클라이언트 코드 분리 없이 변경된 정책을 적용 가능.


추상 Interface와 구현체를 명확하게 분리하는 것이 중요함.

실제로는 "이렇게까지 나눌 필요가 있을까?"라는 생각이 들 수 있다. 인터페이스와 구현체를 분리하는 구조가 과도하게 복잡해지는 것처럼 느껴지기 때문이다.
하지만 인터페이스가 정의되어 있다면, 기존 코드를 수정하지 않고도 새로운 구현체(Impl)를 만들어 끼워넣기만 하면 되기 때문에 구조적인 유연성과 확장성을 확보할 수 있다.
예를 들어, UserService라는 인터페이스를 만들고 이에 대한 구현체로 UserServiceImpl을 생성하여, 유저 가입(생성) 로직을 작성했다고 가정해보자. 이때, 해당 구현은 MySQL과 연동되어 있다고 하자.
그런데 어떤 이유로 Redis에 유저 정보를 저장해야 하는 상황이 생겼다고 가정하면, 기존의 UserService 인터페이스를 수정할 필요 없이, 동일한 메서드 시그니처를 가지는 RedisUserServiceImpl을 만들어서 사용하면 된다.
즉, 기존 구조는 그대로 두고 구현체만 바꿔치기하면 되므로, OCP 원칙을 만족하게 되며, 코드 변경 없이 새로운 요구사항에 대응할 수 있다.
* 추가로 조건부로 해당 구현체를 사용할거면 @Qualifier("")를 사용하자. 이는 명시적으로 어떤 빈을 주입할지 정하는것이다. 다른 방법으로 @Primary가 있는데 이건 우선순위 설정해주는거 즉 가장 기본으로 사용할 구현체 지정.
* 기본적으론 A구현체가 주입되지만 특정 상황에서 Qualifier로 B구현체를 선택할수도 있음.